

## Project Structure (within web_app)
    .
    ├── BestModel.ipynb
    ├── eda.ipynb
    ├── saved_models
    │   ├── best_logreg_feature_names.joblib
    │   ├── best_logreg_model.joblib
    │   └── best_logreg_scaler.joblib
    ├── Set1Model.ipynb
    ├── Set2Model.ipynb
    ├── Set3Model.ipynb
    ├── Set4Model.ipynb
    └── web_app
        ├── __pycache__
        │   └── main.cpython-312.pyc
        ├── main.py
        ├── README.md
        ├── requirements.txt
        └── static
            └── index.html

- `main.py`: The FastAPI application script. Contains API endpoint definitions, model loading logic, and serves the static frontend.
- `static/`: Directory containing static frontend files.
  - `index.html`: The main HTML page for user interaction.
- `requirements.txt`: Python dependencies required to run this web application.
- `README.md`: This file.

## Prerequisites

- Python 3.8+
- `pip` (Python package installer)
- The necessary model files (`.joblib`, `.keras`) should be present in the `../saved_models/` directory relative to this `web_app` folder. These models are generated by running the Jupyter Notebooks in the parent directory (e.g., `BestModel.ipynb` or the notebook that creates `best_logreg_model.joblib`).

## Setup and Running the Application

1.  **Navigate to the Project Root Directory:**
    Open your terminal and change to the `ECS-171` project root directory.

2.  **Create and Activate a Virtual Environment (Recommended):**
    ```bash
    python3 -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    ```

3.  **Install Dependencies:**
    Navigate into the `web_app` directory and install the required Python packages:
    ```bash
    cd web_app
    pip install -r requirements.txt
    cd .. # Go back to project root or stay in web_app to run uvicorn
    ```
    The `requirements.txt` should include `fastapi`, `uvicorn`, `joblib`, `scikit-learn`, `pandas`, `numpy`, `tensorflow` (if Keras models are used by this app).

4.  **Ensure Model Files are Present:**
    Make sure you have run the relevant Jupyter Notebook (e.g., the one that creates the `best_logreg_...` files) from the parent directory (`ECS-171/`) so that the `saved_models/` directory is populated with:
    - `best_logreg_feature_names.joblib`
    - `best_logreg_scaler.joblib`
    - `best_logreg_model.joblib`
    *(Add other model files here if the app is expanded)*

5.  **Run the FastAPI Application:**
    From the `ECS-171/web_app/` directory (where `main.py` is located):
    ```bash
    uvicorn main:app --reload
    ```
    The `--reload` flag makes the server restart automatically when code changes are detected (useful for development).

6.  **Access the Application:**
    Open your web browser and navigate to:
    - **Frontend:** `http://127.0.0.1:8000/`
    - **API Documentation (Swagger UI):** `http://127.0.0.1:8000/docs`
    - **Alternative API Documentation (ReDoc):** `http://127.0.0.1:8000/redoc`

## API Endpoints

(As currently implemented in `main.py`)

-   **`GET /`**: Serves the `index.html` frontend.
-   **`POST /predict`**:
    -   **Description:** Accepts 5 feature values and returns a breast cancer diagnosis prediction (Malignant/Benign) along with probabilities using the best logistic regression model.
    -   **Request Body (JSON):**
        ```json
        {
          "radius_error": 0.5,
          "worst_texture": 25.0,
          "worst_area": 900.0,
          "worst_smoothness": 0.15,
          "worst_concave_points": 0.2
        }
        ```
    -   **Response Body (JSON):**
        ```json
        {
          "prediction": 0, // 0 for malignant, 1 for benign
          "probability_benign": 0.10,
          "probability_malignant": 0.90,
          "model_used": "Best Logistic Regression",
          "features_received": { /* ...input features... */ },
          "features_expected_by_model": [ /* ...list of feature names... */ ]
        }
        ```

## Future Enhancements (If Applicable)

- Add more models and corresponding endpoints.
- Improve frontend UI/UX.
- Add input validation for feature ranges on the frontend.
- Dockerize the application.
